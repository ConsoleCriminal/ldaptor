#!/usr/bin/python

from ldaptor.apps import webui
from ldaptor.apps.webui import gadget

from twisted.internet import main, app, protocol
from twisted.cred.service import Service
from twisted.cred.identity import Identity
from twisted.cred.perspective import Perspective
from twisted.cred.authorizer import Authorizer
from twisted.internet.defer import Deferred
from twisted.internet import defer, reactor
from twisted.python.failure import Failure
from ldaptor.protocols.ldap import ldapclient, ldapfilter
from ldaptor.protocols import pureldap
from twisted.web import server, guard
from ldaptor import usage

class LDAPAuth(ldapclient.LDAPClient):
    def connectionMade(self):
        ldapclient.LDAPClient.connectionMade(self)
        d=self.bind(self.factory.dn, self.factory.auth)
        del self.factory.auth
        d.chainDeferred(self.factory.defe)

class LDAPAuthFactory(protocol.ClientFactory):
    protocol = LDAPAuth

    def __init__(self, defe, dn, auth, cb_connectionLost):
        self.defe = defe
        self.dn = dn
        self.auth = auth
        self.cb_connectionLost = cb_connectionLost
        self.proto=None

    def connectionFailed(self, connector, reason):
        self.proto=None
        self.defe.errback("connection failed")

    def connectionLost(self, connector):
        self.proto=None
        self.cb_connectionLost()

    def buildProtocol(self, addr):
        p=protocol.ClientFactory.buildProtocol(self, addr)
        self.proto=p
        return p

class LDAPIdentity(Identity):
    def __init__(self, name, dn, application,
                 ldapClientFactoryFactory, ldaphost, ldapport=389):
        Identity.__init__(self, name, application)
        self.dn=dn
        self.ldapClientFactoryFactory=ldapClientFactoryFactory
        self.ldapClientFactory=None
        self.ldaphost=ldaphost
        self.ldapport=ldapport
        self.notify_on_connectionLost = []

    def setPassword(self, plaintext):
        raise NotImplementedError

    def setAlreadyHashedPassword(self, cyphertext):
        raise NotImplementedError

    def challenge(self):
        raise NotImplementedError

    def verifyPassword(self, challenge, hashedPassword):
        raise NotImplementedError

    def getLDAPClient(self):
        if self.ldapClientFactory is None:
            return None
        return self.ldapClientFactory.proto

    def verifyPlainPassword(self, plaintext):
        assert not self.getLDAPClient()
        pwrq = Deferred()
        self.ldapClientFactory = self.ldapClientFactoryFactory(
            pwrq, self.dn, plaintext, self.connectionLost)
        reactor.connectTCP(self.ldaphost, self.ldapport,
                          self.ldapClientFactory)
        return pwrq

    def connectionLost(self):
        self.ldapClientFactory=None
        for cb in self.notify_on_connectionLost:
            cb()
        self.notify_on_connectionLost = []

    def notifyOnConnectionLost(self, cb):
        self.notify_on_connectionLost.append(cb)

class LDAPPerspective(Perspective):
    def __init__(self, perspectiveName, identityName="Nobody"):
        Perspective.__init__(self, perspectiveName, identityName=identityName)
        self.sessions={}

    def attached(self, reference, identity):
        try:
            self.sessions[reference]+=1
        except KeyError:
            self.sessions[reference]=1
        return Perspective.attached(self, reference, identity)

    def detached(self, reference, identity):
        self.sessions[reference]-=1
        if self.sessions[reference]==0:
            del self.sessions[reference]
        return Perspective.detached(self, reference, identity)

    def connectionLost(self):
        for session in self.sessions.keys():
            session.expire()

class LDAPFetchIdentity(ldapclient.LDAPSearch):
    def __init__(self, deferred, client, dn):
        ldapclient.LDAPSearch.__init__(self, deferred, client,
                                       baseObject=dn,
                                       scope=pureldap.LDAP_SCOPE_baseObject,
                                       typesOnly=1)
        self.dn = dn
        self.found = None

        deferred.addCallbacks(callback=self.process,
                              errback=lambda x: x)

    def process(self, dummy):
        if self.found:
            return self.found
        else:
            raise LDAPUnknownError(ldaperrors.other, "unauthorized")

    def handle_entry(self, objectName, attributes):
        if not self.found:
            self.found = str(objectName)
        else:
            raise "GOT DUPLICATES (TODO)"

class LDAPSearchIdentity(ldapclient.LDAPSearch):
    def __init__(self, deferred, client,
                 baseObject, filter):
        ldapclient.LDAPSearch.__init__(self, deferred, client,
                                       baseObject=baseObject,
                                       filter=filter,
                                       typesOnly=1,
                                       sizeLimit=1)
        self.found = None

        deferred.addCallbacks(callback=self.process,
                              errback=lambda x: x)

    def process(self, dummy):
        if self.found:
            return self.found
        else:
            raise LDAPUnknownError(ldaperrors.other, "unauthorized")

    def handle_entry(self, objectName, attributes):
        if not self.found:
            self.found = str(objectName)
        else:
            raise "GOT DUPLICATES (TODO)"

class FetchIdentities(ldapclient.LDAPClient):
    def connectionLost(self):
        ldapclient.LDAPClient.connectionLost(self)
        if self.factory.unregister:
            self.factory.unregister(self)
        
    def connectionMade(self):
        d=self.bind()
        d.addCallback(self._handle_bind_success)

    def _handle_bind_success(self, x):
        matchedDN, serverSaslCreds = x
        if self.factory.register:
            self.factory.register(self)

    def fetch(self, name):
        deferred=defer.Deferred()
        LDAPFetchIdentity(deferred=deferred,
                          client=self,
                          dn=name)
        deferred.addCallbacks(callback=self._gotIdentityDN,
                              callbackArgs=(name,),
                              errback=self.search,
                              errbackArgs=(name,))
        return deferred

    def search(self, fail, name):
        filter=None
        try:
            filter=ldapfilter.parseFilter(name)
        except ldapfilter.InvalidLDAPFilter:
            try:
                filter=ldapfilter.parseFilter('('+name+')')
            except ldapfilter.InvalidLDAPFilter:
                if self.factory.ldapFilterTemplate is not None:
                    try:
                        filter=ldapfilter.parseFilter(
                            self.factory.ldapFilterTemplate
                            % {'name':name})
                    except ldapfilter.InvalidLDAPFilter:
                        pass

        deferred=defer.Deferred()
        if filter is None:
            deferred.errback(Failure('No such Identity'))
        else:
            LDAPSearchIdentity(deferred=deferred,
                               client=self,
                               baseObject=self.factory.ldapbase,
                               filter=filter)
            deferred.addCallbacks(callback=self._gotIdentityDN,
                                  callbackArgs=(name,),
                                  errback=self.search)
        return deferred

    def _gotIdentityDN(self, dn, name):
        ident = LDAPIdentity(name, dn, self.factory.application,
                             LDAPAuthFactory,
                             self.factory.ldaphost, self.factory.ldapport)
        #TODO I don't want to enumerate them here!
        ident.addKeyByString("edit", name)
        return ident

class FetchIdentitiesFactory(protocol.ClientFactory):
    protocol = FetchIdentities
    def __init__(self,
                 ldaphost=None,
                 ldapport=389,
                 ldapbase='',
                 ldapFilterTemplate=None,
                 register=None, unregister=None,
                 application=None):
        self.register = register
        self.unregister = unregister
        assert application
        self.application = application
        self.ldaphost = ldaphost
        self.ldapport = ldapport
        self.ldapbase = ldapbase
        self.ldapFilterTemplate = ldapFilterTemplate

class LDAPAuthorizer(Authorizer):
    def __init__(self, ldaphost, ldapport, ldapbase, ldapFilterTemplate=None):
        self.ldaphost = ldaphost
        self.ldapport = ldapport
        self.ldapbase = ldapbase
        self.ldapFilterTemplate = ldapFilterTemplate
        self.fetcher = None
        self.pendingIdentityRequests = {}

    def registerFetcher(self, fetcher):
        """Register the identity fetcher."""
        assert not self.fetcher
        self.fetcher = fetcher

    def unregisterFetcher(self, fetcher):
        """Unregister the identity fetcher."""
        assert self.fetcher==fetcher #TODO fails when LDAP server is stopped
        self.fetcher = None

    def setApplication(self, application):
        Authorizer.setApplication(self, application)
        factory = FetchIdentitiesFactory(
            ldaphost=self.ldaphost,
            ldapport=self.ldapport,
            ldapbase=self.ldapbase,
            ldapFilterTemplate=self.ldapFilterTemplate,
            register=self.registerFetcher,
            unregister=self.unregisterFetcher,
            application=application,
            )
        application.connectTCP(self.ldaphost, self.ldapport, factory)

    def getIdentityRequest(self, name):
        """Get a Deferred callback registration object.

        I return a deferred (twisted.internet.defer.Deferred) which will
        be called back to when an identity is discovered to be available
        (or errback for unavailable).  It will be returned unarmed, so
        you must arm it yourself.
        """

        if not self.fetcher:
            req = Deferred()
            req.errback("unable to serve")
        else:
            req = self.fetcher.fetch(name)
        return req

class LDAPService(Service):
    def _ident_ok(self, ident, name, req):
        req.callback(self.createPerspective(name))

    def _ident_fail(self, msg, name, req):
        req.errback("No such perspective %s: %s"%(name, msg))

    def loadPerspective(self, name):
        identreq = self.application.authorizer.getIdentityRequest(name)
        req = Deferred()
        identreq.addCallback(self._ident_ok, name, req)
        identreq.addErrback(self._ident_fail, name, req)
        identreq.arm()
        return req

    def getPerspectiveRequest(self, name):
        try:
            p = self.getPerspectiveNamed(name)
        except KeyError:
            return self.loadPerspective(name)
        else:
            return defer.succeed(p)


class MyOptions(usage.Options, usage.Options_hostport, usage.Options_base):
    """LDAPtor Web User Interface"""

    optParameters = (
        ('http-port', None, '8080',
         "listen on this port"),
        ('identity-search', None,
         '(|(cn=%(name)s)(uid=%(name)s))',
         "unknown identities are searched with this filter"),
        )

    def postOptions_httpport(self):
        try:
            val = int(self.opts['http-port'])
        except ValueError:
            raise usage.UsageError, "%s value must be numeric" % 'http-port'
        self.opts['http-port'] = val
        
if __name__ == '__main__':
    import sys
    try:
        config = MyOptions()
        config.parseOptions()
    except usage.UsageError, ue:
        sys.stderr.write('%s: %s\n' % (sys.argv[0], ue))
        sys.exit(1)
    application = app.Application(
        'ldaptor-webui',
        authorizer=LDAPAuthorizer(ldaphost=config.opts['ldap-host'],
                                  ldapport=config.opts['ldap-port'],
                                  ldapbase=config.opts['base'],
                                  ldapFilterTemplate=config.opts['identity-search'],
                                  ))
    svc = LDAPService("edit", application)
    svc.perspectiveClass = LDAPPerspective
    gdgt = gadget.LdaptorWebUIGadget(svc,
                                     baseObject=config.opts['base'],
                                     ldaphost=config.opts['ldap-host'],
                                     ldapport=config.opts['ldap-port'],
                                     )
    
    sit = server.Site(gdgt)
    sit.application = application
    application.listenTCP(config.opts['http-port'], sit)
    application.run(save=0)
