#!/usr/bin/python

import sys
from twisted.internet.defer import succeed, fail
from twisted.internet import defer, reactor
from twisted.internet.stdio import StandardIO
from twisted.protocols.basic import LineReceiver
from twisted.internet.protocol import ClientFactory
from twisted.python.failure import Failure
from ldaptor.protocols.ldap import ldapclient, distinguishedname, ldapconnector
from ldaptor.protocols.ldap.ldapsyntax import LDAPObject
from ldaptor import usage
from cStringIO import StringIO

class ExitSentinel:
    pass

class Search(ldapclient.LDAPClient):
    pdnsPipeProtocol = None

    def connectionMade(self):
	d=self.bind()
	d.addCallback(self.bind_ok)
	d.addErrback(lambda dummy: self.transport.loseConnection())

    def bind_ok(self, dummy):
	o = LDAPObject(client=self, dn=self.factory.base)
	self.pdnsPipeProtocol = PdnsPipeProtocol(o, self.factory.dnsDomain)
	reactor.addReader(StandardIO(self.pdnsPipeProtocol))

    def connectionLost(self, reason):
	if self.pdnsPipeProtocol:
	    self.pdnsPipeProtocol.connectionLost()

class SearchFactory(ClientFactory):
    protocol = Search
    ldapClient = None

    def __init__(self, base, dnsDomain):
	self.base=base
	self.dnsDomain=dnsDomain

    def buildProtocol(self, addr):
	p = ClientFactory.buildProtocol(self, addr)
	return p

class PdnsPipeProtocol(LineReceiver):
    delimiter = '\n'
    state = 'start'

    def __init__(self, ldapObject, dnsDomain):
	self.work=[]
	self.ldapObject = ldapObject
	self.dnsDomain = dnsDomain

    def _doWork(self):
	while self.work:
	    if isinstance(self.work[0][0], defer.Deferred):
		# end of done items, stop and wait for completions
		break
	    else:
		done=self.work.pop(0)

		if done == [ExitSentinel]:
		    # that's it, I'm outtahere
		    assert not self.work
		    reactor.stop()
		else:
		    for line in done:
			self.sendLine(line)
		    sys.stdout.flush()

    def completed(self, result, who):
	who[:]=result
	self._doWork()

    def failed(self, result, who):
	io = StringIO()
	result.printTraceback(file=io)
	who[:]=['LOG\t%s' % line
		for line in io.getvalue().splitlines()] \
		+ ['FAIL']
	self._doWork()

    def do_start_HELO(self, rest):
	if rest=='1':
	    self.state = 'main'
	    return succeed(['OK\t%s' % sys.argv[0]])
	else:
	    return succeed(['FAIL'])

    def _gotA(self, results, qname, qclass, qtype, ident):
	r=[]
	for o in results:
	    for ip in o.get('ipHostNumber', ()):
		r.append('\t'.join(('DATA', qname, qclass, qtype,
				    '3600', ident, ip)))
	r.append('END')
	return r

    def question_A(self, qname,qclass,ident,ipAddress):
	ident='-1'
	if not qname.endswith('.'+self.dnsDomain):
	    return succeed(['END'])
	cn=qname[:-len('.'+self.dnsDomain)]
	d=self.ldapObject.search(filterText='(&(cn=%s)(ipHostNumber=*))'%cn,
				 attributes=['ipHostNumber'])
	d.addCallback(self._gotA, qname, qclass, 'A', ident)
	return d

    def question_ANY(self, qname,qclass,ident,ipAddress):
	if qname.endswith('.in-addr.arpa'):
	    return self.question_PTR(qname,qclass,ident,ipAddress)
	else:
	    return self.question_A(qname,qclass,ident,ipAddress)

    def _gotPTR(self, results, qname, qclass, qtype, ident):
	r=[]
	for o in results:
	    for cn in o.get('cn', ()):
		r.append('\t'.join(('DATA', qname, qclass, qtype,
				    '3600', ident,
				    cn+'.'+self.dnsDomain+'.')))
	r.append('END')
	return r

    def question_PTR(self, qname,qclass,ident,ipAddress):
	ident='-1'
	if not qname.endswith('.in-addr.arpa'):
	    return succeed(['END'])

	octets=qname[:-len('.in-addr.arpa')].split('.')
	if len(octets)!=4:
	    return succeed(['END'])
	octets.reverse()
	ip='.'.join(octets)
	d=self.ldapObject.search(filterText='(ipHostNumber=%s)'%ip,
				 attributes=['cn'])
	d.addCallback(self._gotPTR, qname, qclass, 'PTR', ident)
	return d

    def do_main_Q(self, rest):
	try:
	    qname,qclass,qtype,ident,ipAddress=rest.split('\t', 4)
	except ValueError:
	    return succeed(['LOG\tInvalid question: %s' % repr(rest),
			    'END'])
	if qclass!='IN':
	    return succeed(['LOG\tInvalid qclass: %s' % repr(qclass),
			    'END'])
	q=getattr(self, 'question_'+qtype, None)
	if q:
	    return q(qname,qclass,ident,ipAddress)
	else:
	    return succeed(['END'])

    def do_main_AXFR(self, rest):
	return succeed(['LOG\tRefusing AXFR', 'END'])

    def do_main_PING(self, rest):
	#TODO it's undocumented what I should be saying
	return succeed(['END'])

    def lineReceived(self, line):
	try:
	    try:
		type,rest=line.split('\t', 1)
	    except ValueError:
		type=line
		rest=''
	    f=getattr(self, 'do_'+self.state+'_'+type, None)
	    if f:
		d=f(rest)
	    else:
		d=succeed(['LOG\tUnknown command %s in state %s'
			   % (repr(type), self.state),
			   'END'])
	except:
	    f=Failure()
	    d=fail(f)

	l=[d]
	self.work.append(l)
	d.addCallback(self.completed, l)
	d.addErrback(self.failed, l)

    def connectionLost(self):
	self.work.append([ExitSentinel])
	self._doWork()

exitStatus = 0

def main(base, serviceLocationOverride, dnsDomain):
    s=SearchFactory(base, dnsDomain)
    dn = distinguishedname.DistinguishedName(stringValue=base)
    c=ldapconnector.LDAPConnector(reactor, dn, s, overrides=serviceLocationOverride)
    c.connect()
    reactor.run()
    sys.exit(exitStatus)

class MyOptions(usage.Options, usage.Options_service_location, usage.Options_base):
    """LDAPtor PDNS pipe backend"""

    optParameters = (
	('dns-domain', None, 'example.com',
	 "DNS domain name"),
	)

if __name__ == "__main__":
    try:
	config = MyOptions()
	config.parseOptions()
    except usage.UsageError, ue:
	sys.stderr.write('%s: %s\n' % (sys.argv[0], ue))
	sys.exit(1)

    from twisted.python import log
    log.startLogging(sys.stderr, setStdout=0)
    main(config.opts['base'],
	 config.opts['service-location'],
	 config.opts['dns-domain'])
