#!/usr/bin/python

from ldaptor.protocols.ldap import distinguishedname, ldapconnector, ldapsyntax, ldapclient
from ldaptor.protocols import pureber, pureldap
from ldaptor import usage, ldapfilter, config
from socket import inet_aton, inet_ntoa
import sys
from twisted.internet import protocol, defer, reactor

def my_aton_octets(ip):
    s=inet_aton(ip)
    octets=map(None, s)
    n=0L
    for o in octets:
	n=n<<8
	n+=ord(o)
    return n

def my_aton_numbits(num):
    n=0L
    while num>0:
	n>>=1
	n |= 2**31
	num-=1
    return n

def my_aton(ip):
    try:
	i=int(ip)
    except ValueError:
	return my_aton_octets(ip)
    else:
	return my_aton_numbits(i)

def my_ntoa(n):
    s=(
	chr((n>>24)&0xFF)
	+ chr((n>>16)&0xFF)
	+ chr((n>>8)&0xFF)
	+ chr(n&0xFF)
       )
    ip=inet_ntoa(s)
    return ip

def printIPAddress(name, ip):
    print 'A'+name+'.%|86400|'+ip

def printPTR(name, ip):
    octets = ip.split('.')
    octets.reverse()
    octets.append('in-addr.arpa.')
    print 'P'+('.'.join(octets))+'|86400|'+name+'.%'

class HostIPAddress:
    def __init__(self, host, ipAddress):
	self.host=host
	self.ipAddress=ipAddress

    def printZone(self, domain):
	print '#  '+self.host.dn
	printIPAddress(self.host.name+'.'+domain, self.ipAddress)
	printPTR(self.host.name+'.'+domain, self.ipAddress)

    def __repr__(self):
	return (self.__class__.__name__
		+'('
		+'host=%s, ' % id(self.host)
		+'ipAddress=%s' % repr(self.ipAddress)
		+')')

class Host:
    def __init__(self, dn, name, ipAddresses):
	self.dn=dn
	self.name=name
	self.ipAddresses=[HostIPAddress(self, ip) for ip in ipAddresses]

    def __repr__(self):
	return (self.__class__.__name__
		+'('
		+'dn=%s, ' % repr(self.dn)
		+'name=%s, ' % repr(self.name)
		+'ipAddresses=%s' % repr(self.ipAddresses)
		+')')

class Net:
    def __init__(self, dn, name, address, mask):
	self.dn=dn
	self.name=name
	self.address=address
	self.mask=mask
	self.hosts=[]

    def isInNet(self, ipAddress):
	net = my_aton(self.address)
	mask = my_aton(self.mask)
	ip = my_aton(ipAddress)
	if ip&mask == net:
	    return 1
	return 0

    def addHost(self, host):
	assert self.isInNet(host.ipAddress)
	self.hosts.append(host)

    def printZone(self):
	print '#'+self.dn
	printIPAddress(self.name, self.address)
	printPTR(self.name, self.address)
	printIPAddress('netmask.'+self.name, self.mask)
	ip = my_aton(self.address)
	mask = my_aton(self.mask)
	broadcast = my_ntoa(ip|~mask)
	printIPAddress('broadcast.'+self.name, broadcast)
	printPTR('broadcast.'+self.name, broadcast)

	print '# hosts begin'
	for host in self.hosts:
	    host.printZone(self.name)
	print '# hosts end'
	print

    def __repr__(self):
	return (self.__class__.__name__
		+'('
		+'dn=%s, ' % repr(self.dn)
		+'name=%s, ' % repr(self.name)
		+'address=%s, ' % repr(self.address)
		+'mask=%s' % repr(self.mask)
		+')')



exitStatus=0

def error(fail):
    print >>sys.stderr, 'fail:', str(fail) #.getErrorMessage()
    global exitStatus
    exitStatus=1

def only(e, attrName):
    assert len(e[attrName])==1, \
           "object %s attribute %r has multiple values: %s" \
           % (e.dn, attrName, e[attrName])
    for val in e[attrName]:
        return val

def getNets(e, filter):
    filt=pureldap.LDAPFilter_and(value=(
        pureldap.LDAPFilter_present('cn'),
        pureldap.LDAPFilter_present('ipNetworkNumber'),
        pureldap.LDAPFilter_present('ipNetmaskNumber'),
        ))
    if filter:
        filt = pureldap.LDAPFilter_and(value=(filter, filt))
    d = e.search(filterObject=filt,
                 attributes=['cn',
                             'ipNetworkNumber',
                             'ipNetmaskNumber',
                             ])
    def _cbGotNets(nets):
        r = []
        for e in nets:
            net = Net(str(e.dn),
                      str(only(e, 'cn')),
                      str(only(e, 'ipNetworkNumber')),
                      str(only(e, 'ipNetmaskNumber')))
            r.append(net)
        return r
    d.addCallback(_cbGotNets)
    return d

def getHosts(nets, e, filter):
    filt=pureldap.LDAPFilter_equalityMatch(attributeDesc=pureldap.LDAPAttributeDescription('objectClass'),
                                           assertionValue=pureber.BEROctetString('ipHost'))
    if filter:
        filt = pureldap.LDAPFilter_and(value=(filter, filt))
    d = e.search(filterObject=filt,
                 attributes=['ipHostNumber',
                             'cn'])
    def _cbGotHosts(hosts):
        r = []
        for e in hosts:
            host = Host(str(e.dn),
                        str(only(e, 'cn')),
                        map(str, e['ipHostNumber']))
            r.append(host)
        return r
    d.addCallback(_cbGotHosts)
    d.addCallback(lambda hosts: (nets, hosts))
    return d

def show((nets, hosts)):
    for host in hosts:
        for hostIP in host.ipAddresses:
            parent=None
            for net in nets:
                if net.isInNet(hostIP.ipAddress):
                    parent=net
                    break

            if parent:
                parent.addHost(hostIP)
            else:
                sys.stderr.write("IP address %s is in no net, discarding.\n" % hostIP)

    for net in nets:
        net.printZone()

def cbConnected(client, cfg, filter):
    e = ldapsyntax.LDAPEntryWithClient(client, cfg.getBaseDN())
    d = getNets(e, filter)
    d.addCallback(getHosts, e, filter)
    def unbind(r, e):
        e.client.unbind()
        return r
    d.addCallback(unbind, e)
    d.addCallback(show)
    return d

def main(cfg, filter_text):
    from twisted.python import log
    log.startLogging(sys.stderr, setStdout=0)

    try:
        baseDN = cfg.getBaseDN()
    except config.MissingBaseDNError, e:
        print >>sys.stderr, "%s: %s." % (sys.argv[0], e)
        sys.exit(1)

    if filter_text is not None:
	filt = ldapfilter.parseFilter(filter_text)
    else:
	filt = None

    c=ldapconnector.LDAPClientCreator(reactor, ldapclient.LDAPClient)
    d = c.connectAnonymously(
        baseDN,
        overrides=cfg.getServiceLocationOverrides())
    d.addCallback(cbConnected, cfg, filt)
    d.addErrback(error)
    d.addBoth(lambda x: reactor.stop())

    reactor.run()
    sys.exit(exitStatus)

class MyOptions(usage.Options, usage.Options_service_location, usage.Options_base_optional):
    """LDAPtor maradns zone file exporter"""
    def parseArgs(self, filter=None):
	self.opts['filter'] = filter

if __name__ == "__main__":
    import sys
    try:
	opts = MyOptions()
	opts.parseOptions()
    except usage.UsageError, ue:
	sys.stderr.write('%s: %s\n' % (sys.argv[0], ue))
	sys.exit(1)

    cfg = config.LDAPConfig(baseDN=opts['base'],
                            serviceLocationOverrides=opts['service-location'])
    main(cfg,
         opts['filter'])
